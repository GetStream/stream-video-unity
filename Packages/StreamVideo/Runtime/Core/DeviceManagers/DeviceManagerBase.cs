using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using StreamVideo.Core.LowLevelClient;
using StreamVideo.Libs.Logs;

namespace StreamVideo.Core.DeviceManagers
{
    public delegate void DeviceEnabledChangeHandler(bool isEnabled);

    public delegate void
        SelectedDeviceChangeHandler<in TDeviceInfo>(TDeviceInfo previousDevice, TDeviceInfo currentDevice);

    internal abstract class DeviceManagerBase<TDeviceInfo> : IDeviceManager<TDeviceInfo> where TDeviceInfo : struct
    {
        public abstract event DeviceEnabledChangeHandler IsEnabledChanged;

        public event SelectedDeviceChangeHandler<TDeviceInfo> SelectedDeviceChanged;

        //StreamTODO: remove _isEnabled. Make this abstract co that derived classes map directly to RtcSession._publisherAudioTrackIsEnabled & RtcSession._publisherVideoTrackIsEnabled
        //The IsEnabledChanged event would be triggered in reaction to RtcSession events. This way anyone can directly interact with RtcSession and the DeviceManager would reflect the same state
        public abstract bool IsEnabled { get; protected set; }

        public TDeviceInfo SelectedDevice
        {
            get => _selectedDevice;
            protected set
            {
                if (EqualityComparer<TDeviceInfo>.Default.Equals(value, _selectedDevice))
                {
                    return;
                }

                var prev = _selectedDevice;
                _selectedDevice = value;
                OnDeviceChanging(prev, value);
                SelectedDeviceChanged?.Invoke(prev, value);
            }
        }

        public void Enable() => SetEnabled(true);

        public void Disable() => SetEnabled(false);

        public void SetEnabled(bool isEnabled)
        {
            if (IsEnabled == isEnabled)
            {
                return;
            }

            IsEnabled = isEnabled;
        }

        public abstract IEnumerable<TDeviceInfo> EnumerateDevices();

        // StreamTODO: figure out if this is needed. This was handy on Windows because there's often many virtual devices generated by various software so it's practical to go through all devices and preselect one that actually works.
        // For mobile, we're steering towards native binding and for now we're exposing hardware devices only
        // Perhaps we should later replace this with SmartSelect -> Window/Linux: find first working or check OS-selected device, Mobile: prefer external headset, than built-in microphone
        public Task<bool> TestDeviceAsync(TDeviceInfo device, float timeout = 1f)
        {
            const float MinTimeout = 0f;
            const float MaxTimeout = 20f;

            if (timeout <= MinTimeout || timeout > MaxTimeout)
            {
                throw new ArgumentOutOfRangeException(
                    $"'{nameof(timeout)}' argument must be between {MinTimeout} and {MaxTimeout} seconds, given: {timeout}");
            }

            return OnTestDeviceAsync(device, (int)(timeout * 1000));
        }

        // StreamTODO: add filter option. E.g. so we can easily consider only front cameras on ios/android
        public async Task<TDeviceInfo?> TryFindFirstWorkingDeviceAsync(float testTimeoutPerDevice = 1f)
        {
            foreach (var device in EnumerateDevices())
            {
                var isWorking = await TestDeviceAsync(device, testTimeoutPerDevice);
                if (isWorking)
                {
                    return device;
                }
            }

            return null;
        }

        public void Dispose() => OnDisposing();

        internal DeviceManagerBase(RtcSession rtcSession, IInternalStreamVideoClient client, ILogs logs)
        {
            RtcSession = rtcSession ?? throw new ArgumentNullException(nameof(rtcSession));
            Client = client ?? throw new ArgumentNullException(nameof(client));
            Logs = logs ?? throw new ArgumentNullException(nameof(logs));

            //StreamTodo: react to when video & audio streams become available and disable them if IsEnabled was set to false before the call
        }

        internal void Update() => OnUpdate();

        protected RtcSession RtcSession { get; }
        protected IInternalStreamVideoClient Client { get; }
        protected ILogs Logs { get; }

        protected abstract Task<bool> OnTestDeviceAsync(TDeviceInfo device, int msTimeout);

        protected virtual void OnUpdate()
        {
        }

        protected virtual void OnDisposing()
        {
        }
        
        protected virtual void OnDeviceChanging(TDeviceInfo prev, TDeviceInfo current)
        {
        }

        private TDeviceInfo _selectedDevice;
    }
}